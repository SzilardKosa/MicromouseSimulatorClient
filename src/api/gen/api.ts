/* tslint:disable */
/* eslint-disable */
/**
 * MicromouseSimulatorBackend.API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlgorithmDTO
 */
export interface AlgorithmDTO {
    /**
     * 
     * @type {string}
     * @memberof AlgorithmDTO
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AlgorithmDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorithmDTO
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof AlgorithmDTO
     */
    codeText: string;
}
/**
 * 
 * @export
 * @interface Coordinate
 */
export interface Coordinate {
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Coordinate
     */
    y?: number;
}
/**
 * 
 * @export
 * @interface GoalAreaDTO
 */
export interface GoalAreaDTO {
    /**
     * 
     * @type {Coordinate}
     * @memberof GoalAreaDTO
     */
    topLeft: Coordinate;
    /**
     * 
     * @type {Coordinate}
     * @memberof GoalAreaDTO
     */
    bottomRight: Coordinate;
}
/**
 * 
 * @export
 * @interface MazeDTO
 */
export interface MazeDTO {
    /**
     * 
     * @type {string}
     * @memberof MazeDTO
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MazeDTO
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MazeDTO
     */
    isFullSize: boolean;
    /**
     * 
     * @type {number}
     * @memberof MazeDTO
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof MazeDTO
     */
    height: number;
    /**
     * 
     * @type {GoalAreaDTO}
     * @memberof MazeDTO
     */
    goalArea: GoalAreaDTO;
    /**
     * 
     * @type {string}
     * @memberof MazeDTO
     */
    walls: string;
}
/**
 * 
 * @export
 * @interface MouseDTO
 */
export interface MouseDTO {
    /**
     * 
     * @type {string}
     * @memberof MouseDTO
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MouseDTO
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MouseDTO
     */
    isFullSize: boolean;
}
/**
 * 
 * @export
 * @interface SimulationDTO
 */
export interface SimulationDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    algorithmId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    mazeId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    mouseId?: string | null;
}
/**
 * 
 * @export
 * @interface SimulationExpandedDTO
 */
export interface SimulationExpandedDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationExpandedDTO
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationExpandedDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationExpandedDTO
     */
    algorithmId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationExpandedDTO
     */
    mazeId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SimulationExpandedDTO
     */
    mouseId?: string | null;
    /**
     * 
     * @type {AlgorithmDTO}
     * @memberof SimulationExpandedDTO
     */
    algorithm?: AlgorithmDTO;
    /**
     * 
     * @type {MazeDTO}
     * @memberof SimulationExpandedDTO
     */
    maze?: MazeDTO;
    /**
     * 
     * @type {MouseDTO}
     * @memberof SimulationExpandedDTO
     */
    mouse?: MouseDTO;
}
/**
 * 
 * @export
 * @interface SimulationResultDTO
 */
export interface SimulationResultDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationResultDTO
     */
    error?: string | null;
    /**
     * 
     * @type {SimulationExpandedDTO}
     * @memberof SimulationResultDTO
     */
    simulation?: SimulationExpandedDTO;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimulationResultDTO
     */
    history?: Array<string> | null;
}

/**
 * AlgorithmApi - axios parameter creator
 * @export
 */
export const AlgorithmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('algorithmsIdDelete', 'id', id)
            const localVarPath = `/algorithms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('algorithmsIdGet', 'id', id)
            const localVarPath = `/algorithms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdPut: async (id: string, algorithmDTO?: AlgorithmDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('algorithmsIdPut', 'id', id)
            const localVarPath = `/algorithms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(algorithmDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsPost: async (algorithmDTO?: AlgorithmDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(algorithmDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlgorithmApi - functional programming interface
 * @export
 */
export const AlgorithmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlgorithmApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async algorithmsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlgorithmDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.algorithmsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async algorithmsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.algorithmsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async algorithmsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlgorithmDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.algorithmsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async algorithmsIdPut(id: string, algorithmDTO?: AlgorithmDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.algorithmsIdPut(id, algorithmDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async algorithmsPost(algorithmDTO?: AlgorithmDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlgorithmDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.algorithmsPost(algorithmDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlgorithmApi - factory interface
 * @export
 */
export const AlgorithmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlgorithmApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsGet(options?: any): AxiosPromise<Array<AlgorithmDTO>> {
            return localVarFp.algorithmsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.algorithmsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdGet(id: string, options?: any): AxiosPromise<AlgorithmDTO> {
            return localVarFp.algorithmsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsIdPut(id: string, algorithmDTO?: AlgorithmDTO, options?: any): AxiosPromise<void> {
            return localVarFp.algorithmsIdPut(id, algorithmDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AlgorithmDTO} [algorithmDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        algorithmsPost(algorithmDTO?: AlgorithmDTO, options?: any): AxiosPromise<AlgorithmDTO> {
            return localVarFp.algorithmsPost(algorithmDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlgorithmApi - object-oriented interface
 * @export
 * @class AlgorithmApi
 * @extends {BaseAPI}
 */
export class AlgorithmApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlgorithmApi
     */
    public algorithmsGet(options?: any) {
        return AlgorithmApiFp(this.configuration).algorithmsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlgorithmApi
     */
    public algorithmsIdDelete(id: string, options?: any) {
        return AlgorithmApiFp(this.configuration).algorithmsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlgorithmApi
     */
    public algorithmsIdGet(id: string, options?: any) {
        return AlgorithmApiFp(this.configuration).algorithmsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {AlgorithmDTO} [algorithmDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlgorithmApi
     */
    public algorithmsIdPut(id: string, algorithmDTO?: AlgorithmDTO, options?: any) {
        return AlgorithmApiFp(this.configuration).algorithmsIdPut(id, algorithmDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlgorithmDTO} [algorithmDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlgorithmApi
     */
    public algorithmsPost(algorithmDTO?: AlgorithmDTO, options?: any) {
        return AlgorithmApiFp(this.configuration).algorithmsPost(algorithmDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MazeApi - axios parameter creator
 * @export
 */
export const MazeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/mazes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mazesIdDelete', 'id', id)
            const localVarPath = `/mazes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mazesIdGet', 'id', id)
            const localVarPath = `/mazes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdPut: async (id: string, mazeDTO?: MazeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mazesIdPut', 'id', id)
            const localVarPath = `/mazes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mazeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesPost: async (mazeDTO?: MazeDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/mazes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mazeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MazeApi - functional programming interface
 * @export
 */
export const MazeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MazeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mazesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MazeDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mazesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mazesIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mazesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mazesIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MazeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mazesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mazesIdPut(id: string, mazeDTO?: MazeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mazesIdPut(id, mazeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mazesPost(mazeDTO?: MazeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MazeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mazesPost(mazeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MazeApi - factory interface
 * @export
 */
export const MazeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MazeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesGet(options?: any): AxiosPromise<Array<MazeDTO>> {
            return localVarFp.mazesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.mazesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdGet(id: string, options?: any): AxiosPromise<MazeDTO> {
            return localVarFp.mazesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesIdPut(id: string, mazeDTO?: MazeDTO, options?: any): AxiosPromise<void> {
            return localVarFp.mazesIdPut(id, mazeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MazeDTO} [mazeDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mazesPost(mazeDTO?: MazeDTO, options?: any): AxiosPromise<MazeDTO> {
            return localVarFp.mazesPost(mazeDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MazeApi - object-oriented interface
 * @export
 * @class MazeApi
 * @extends {BaseAPI}
 */
export class MazeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MazeApi
     */
    public mazesGet(options?: any) {
        return MazeApiFp(this.configuration).mazesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MazeApi
     */
    public mazesIdDelete(id: string, options?: any) {
        return MazeApiFp(this.configuration).mazesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MazeApi
     */
    public mazesIdGet(id: string, options?: any) {
        return MazeApiFp(this.configuration).mazesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {MazeDTO} [mazeDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MazeApi
     */
    public mazesIdPut(id: string, mazeDTO?: MazeDTO, options?: any) {
        return MazeApiFp(this.configuration).mazesIdPut(id, mazeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MazeDTO} [mazeDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MazeApi
     */
    public mazesPost(mazeDTO?: MazeDTO, options?: any) {
        return MazeApiFp(this.configuration).mazesPost(mazeDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MouseApi - axios parameter creator
 * @export
 */
export const MouseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/mice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('miceIdDelete', 'id', id)
            const localVarPath = `/mice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('miceIdGet', 'id', id)
            const localVarPath = `/mice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdPut: async (id: string, mouseDTO?: MouseDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('miceIdPut', 'id', id)
            const localVarPath = `/mice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mouseDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        micePost: async (mouseDTO?: MouseDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/mice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mouseDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MouseApi - functional programming interface
 * @export
 */
export const MouseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MouseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miceGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MouseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miceGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miceIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miceIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miceIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miceIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miceIdPut(id: string, mouseDTO?: MouseDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miceIdPut(id, mouseDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async micePost(mouseDTO?: MouseDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MouseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.micePost(mouseDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MouseApi - factory interface
 * @export
 */
export const MouseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MouseApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceGet(options?: any): AxiosPromise<Array<MouseDTO>> {
            return localVarFp.miceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.miceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdGet(id: string, options?: any): AxiosPromise<MouseDTO> {
            return localVarFp.miceIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miceIdPut(id: string, mouseDTO?: MouseDTO, options?: any): AxiosPromise<void> {
            return localVarFp.miceIdPut(id, mouseDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MouseDTO} [mouseDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        micePost(mouseDTO?: MouseDTO, options?: any): AxiosPromise<MouseDTO> {
            return localVarFp.micePost(mouseDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MouseApi - object-oriented interface
 * @export
 * @class MouseApi
 * @extends {BaseAPI}
 */
export class MouseApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MouseApi
     */
    public miceGet(options?: any) {
        return MouseApiFp(this.configuration).miceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MouseApi
     */
    public miceIdDelete(id: string, options?: any) {
        return MouseApiFp(this.configuration).miceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MouseApi
     */
    public miceIdGet(id: string, options?: any) {
        return MouseApiFp(this.configuration).miceIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {MouseDTO} [mouseDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MouseApi
     */
    public miceIdPut(id: string, mouseDTO?: MouseDTO, options?: any) {
        return MouseApiFp(this.configuration).miceIdPut(id, mouseDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MouseDTO} [mouseDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MouseApi
     */
    public micePost(mouseDTO?: MouseDTO, options?: any) {
        return MouseApiFp(this.configuration).micePost(mouseDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SimulationApi - axios parameter creator
 * @export
 */
export const SimulationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulationsIdDelete', 'id', id)
            const localVarPath = `/simulations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulationsIdGet', 'id', id)
            const localVarPath = `/simulations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdPut: async (id: string, simulationDTO?: SimulationDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulationsIdPut', 'id', id)
            const localVarPath = `/simulations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simulationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdRunGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulationsIdRunGet', 'id', id)
            const localVarPath = `/simulations/{id}/run`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsPost: async (simulationDTO?: SimulationDTO, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simulationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationApi - functional programming interface
 * @export
 */
export const SimulationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimulationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SimulationExpandedDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationExpandedDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsIdPut(id: string, simulationDTO?: SimulationDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsIdPut(id, simulationDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsIdRunGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsIdRunGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulationsPost(simulationDTO?: SimulationDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulationsPost(simulationDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SimulationApi - factory interface
 * @export
 */
export const SimulationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimulationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsGet(options?: any): AxiosPromise<Array<SimulationExpandedDTO>> {
            return localVarFp.simulationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.simulationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdGet(id: string, options?: any): AxiosPromise<SimulationExpandedDTO> {
            return localVarFp.simulationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdPut(id: string, simulationDTO?: SimulationDTO, options?: any): AxiosPromise<void> {
            return localVarFp.simulationsIdPut(id, simulationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsIdRunGet(id: string, options?: any): AxiosPromise<SimulationResultDTO> {
            return localVarFp.simulationsIdRunGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SimulationDTO} [simulationDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulationsPost(simulationDTO?: SimulationDTO, options?: any): AxiosPromise<SimulationDTO> {
            return localVarFp.simulationsPost(simulationDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimulationApi - object-oriented interface
 * @export
 * @class SimulationApi
 * @extends {BaseAPI}
 */
export class SimulationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsGet(options?: any) {
        return SimulationApiFp(this.configuration).simulationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsIdDelete(id: string, options?: any) {
        return SimulationApiFp(this.configuration).simulationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsIdGet(id: string, options?: any) {
        return SimulationApiFp(this.configuration).simulationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SimulationDTO} [simulationDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsIdPut(id: string, simulationDTO?: SimulationDTO, options?: any) {
        return SimulationApiFp(this.configuration).simulationsIdPut(id, simulationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsIdRunGet(id: string, options?: any) {
        return SimulationApiFp(this.configuration).simulationsIdRunGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SimulationDTO} [simulationDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulationsPost(simulationDTO?: SimulationDTO, options?: any) {
        return SimulationApiFp(this.configuration).simulationsPost(simulationDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


